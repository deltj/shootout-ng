/**
 * Shootout2 - 802.11 monitor mode performance evaluator
 *
 * Copyright 2020 Ted DeLoggio <deltj@outlook.com>
 */
#include "Packet.h"

#define BOOST_TEST_MODULE PacketTest
#define BOOST_TEST_DYN_LINK
#include <boost/test/unit_test.hpp>

#include<vector>
#include<set>

BOOST_AUTO_TEST_CASE( FCS )
{
    static const unsigned char pkt1535[52] = {
        0x00, 0x00, 0x26, 0x00, 0x2f, 0x40, 0x00, 0xa0,
        0x20, 0x08, 0x00, 0xa0, 0x20, 0x08, 0x00, 0x00,
        0x34, 0x5c, 0xb7, 0x97, 0x00, 0x00, 0x00, 0x00,
        0x10, 0x0c, 0x6c, 0x09, 0xc0, 0x00, 0xaa, 0x00,
        0x00, 0x00, 0xa0, 0x00, 0xaa, 0x01, 0xc4, 0x00,
        0x40, 0x01, 0x9c, 0xb7, 0x0d, 0xad, 0xe3, 0xdb,
        0x55, 0xb0, 0xef, 0x92
    };

    //  The packet above has a radiotap header that's 38 bytes and a 4-byte
    //  FCS at the end, so the actual data is 10 bytes
    uint32_t fcs = shootout::calcfcs(pkt1535 + 38, 10);

    BOOST_CHECK_EQUAL(0x55, (uint8_t)(fcs >> 24));
    BOOST_CHECK_EQUAL(0xb0, (uint8_t)(fcs >> 16));
    BOOST_CHECK_EQUAL(0xef, (uint8_t)(fcs >> 8));
    BOOST_CHECK_EQUAL(0x92, (uint8_t)(fcs));
}

BOOST_AUTO_TEST_CASE( Packet_Ctor )
{
    shootout::Packet p;

    BOOST_CHECK_EQUAL(0, p.dataLength);
    BOOST_CHECK_EQUAL(nullptr, p.data);
}

BOOST_AUTO_TEST_CASE( Packet_CopyCtor )
{
    uint8_t data[100];
    for(int i=0; i<100; i++)
        data[i] = 0x55;

    shootout::Packet p1;
    p1.setData(data, 100);

    shootout::Packet p2 = p1;

    uint8_t copiedPacketdata[100];
    const int numCopied = p2.getData(copiedPacketdata, 100);
    BOOST_CHECK_EQUAL(100, numCopied);

    for(int i=0; i<100; ++i)
        BOOST_CHECK_EQUAL(0x55, copiedPacketdata[i]);
}

BOOST_AUTO_TEST_CASE( Packet_GetSetData )
{
    uint8_t data[100];

    for(int i=0; i<100; ++i)
        data[i] = 0x55;

    shootout::Packet p;
    p.setData(data, 100);

    BOOST_CHECK_EQUAL(100, p.dataLength);
    BOOST_CHECK(p.data != nullptr);

    uint8_t copiedPacketdata[100];
    const int numCopied = p.getData(copiedPacketdata, 100);
    BOOST_CHECK_EQUAL(100, numCopied);

    for(int i=0; i<100; ++i)
        BOOST_CHECK_EQUAL(0x55, copiedPacketdata[i]);
}

BOOST_AUTO_TEST_CASE( Packet_GetEmptyPacket )
{
    shootout::Packet p;

    uint8_t buf[100];

    const bool numCopied = p.getData(buf, 100);

    BOOST_CHECK_EQUAL(0, numCopied);
}

BOOST_AUTO_TEST_CASE( Packet_GetNullBuff )
{
    uint8_t data[100];

    shootout::Packet p;
    p.setData(data, 100);

    uint8_t *buf = nullptr;

    const bool numCopied = p.getData(buf, 100);

    BOOST_CHECK_EQUAL(0, numCopied);
}

BOOST_AUTO_TEST_CASE( Packet_GetBuffTooSmall )
{
    uint8_t data[100];

    shootout::Packet p;
    p.setData(data, 100);

    uint8_t buf[99];

    const bool numCopied = p.getData(buf, 99);

    BOOST_CHECK_EQUAL(0, numCopied);
}

BOOST_AUTO_TEST_CASE( Packet_Hash )
{
    uint8_t data1[100];
    for(int i=0; i<100; i++)
        data1[i] = 0x55;

    uint8_t data2[100];
    for(int i=0; i<100; i++)
        data2[i] = 0xAA;

    shootout::Packet p1(data1, 100);

    shootout::Packet p2(data2, 100);

    shootout::Packet p3(data2, 100);

    uint8_t hash1[32];
    memcpy(hash1, p1.hash.hash, 32);

    uint8_t hash2[32];
    memcpy(hash2, p2.hash.hash, 32);

    uint8_t hash3[32];
    memcpy(hash3, p3.hash.hash, 32);

    int compare = memcmp(hash1, hash2, 32);

    BOOST_CHECK(compare != 0);

    compare = memcmp(hash2, hash3, 32);

    BOOST_CHECK(compare == 0);
}

BOOST_AUTO_TEST_CASE( Packet_Set )
{
    uint8_t data1[100];
    for(int i=0; i<100; i++)
        data1[i] = 0x55;

    uint8_t data2[100];
    for(int i=0; i<100; i++)
        data2[i] = 0xAA;

    shootout::Packet p1;
    p1.setData(data1, 100);

    shootout::Packet p2;
    p2.setData(data2, 100);

    shootout::Packet p3;
    p3.setData(data2, 100);

    std::multiset<shootout::Packet, shootout::PacketComparator> ps;
    ps.insert(p1);
    ps.insert(p2);
    ps.insert(p3);

    BOOST_CHECK_EQUAL(3, ps.size());
}

BOOST_AUTO_TEST_CASE( IdenticalBeacons )
{
    //  This test compares the contents of a beacon frame captured by two
    //  different sources.  This test is extremely important, because it
    //  confirms that the differences (e.g. radiotap, fcs) can be ignored for
    //  the purpose of comparing captured frames.

    //  Beacon with sequence number 2533 captured from wlp7s0 (an ax200)
    static const unsigned char pkt1517[260] = {
        0x00, 0x00, 0x26, 0x00, 0x2f, 0x40, 0x00, 0xa0,
        0x20, 0x08, 0x00, 0xa0, 0x20, 0x08, 0x00, 0x00,
        0xbb, 0x2e, 0xb0, 0x97, 0x00, 0x00, 0x00, 0x00,
        0x10, 0x02, 0x6c, 0x09, 0xa0, 0x00, 0xb7, 0x00,
        0x00, 0x00, 0xb4, 0x00, 0xb5, 0x01, 0x80, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xb0, 0xbe, 0x76, 0x44, 0x64, 0x4f, 0xb0, 0xbe,
        0x76, 0x44, 0x64, 0x4f, 0x50, 0x9e, 0x90, 0x51,
        0x45, 0xe6, 0xe6, 0x01, 0x00, 0x00, 0x64, 0x00,
        0x31, 0x14, 0x00, 0x08, 0x34, 0x34, 0x36, 0x34,
        0x35, 0x30, 0x5f, 0x32, 0x01, 0x08, 0x82, 0x84,
        0x8b, 0x96, 0x24, 0x30, 0x48, 0x6c, 0x03, 0x01,
        0x02, 0x05, 0x04, 0x00, 0x01, 0x00, 0x00, 0x2a,
        0x01, 0x00, 0x32, 0x04, 0x0c, 0x12, 0x18, 0x60,
        0x30, 0x14, 0x01, 0x00, 0x00, 0x0f, 0xac, 0x04,
        0x01, 0x00, 0x00, 0x0f, 0xac, 0x04, 0x01, 0x00,
        0x00, 0x0f, 0xac, 0x02, 0x0c, 0x00, 0x46, 0x05,
        0x32, 0x08, 0x01, 0x00, 0x00, 0x2d, 0x1a, 0xbc,
        0x09, 0x1b, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x3d, 0x16, 0x02, 0x08, 0x04, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x4a, 0x0e, 0x14, 0x00, 0x0a, 0x00, 0x2c,
        0x01, 0xc8, 0x00, 0x14, 0x00, 0x05, 0x00, 0x19,
        0x00, 0x7f, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x40, 0xdd, 0x09, 0x00, 0x10, 0x18,
        0x02, 0x06, 0x00, 0x0c, 0x00, 0x00, 0xdd, 0x18,
        0x00, 0x50, 0xf2, 0x02, 0x01, 0x01, 0x84, 0x00,
        0x03, 0xa4, 0x00, 0x00, 0x27, 0xa4, 0x00, 0x00,
        0x42, 0x43, 0x5e, 0x00, 0x62, 0x32, 0x2f, 0x00,
        0x10, 0x72, 0x8a, 0xdc 
    };

    //  Beacon with sequence number 2533 captured from wlp0s20u5u1 (an rtl8812)
    static const unsigned char pkt85[242] = {
        0x00, 0x00, 0x18, 0x00, 0x2e, 0x40, 0x00, 0xa0,
        0x20, 0x08, 0x00, 0x00, 0x00, 0x02, 0x6c, 0x09,
        0xa0, 0x00, 0xc7, 0x00, 0x00, 0x00, 0xc7, 0x00,
        0x80, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xb0, 0xbe, 0x76, 0x44, 0x64, 0x4f,
        0xb0, 0xbe, 0x76, 0x44, 0x64, 0x4f, 0x50, 0x9e,
        0x90, 0x51, 0x45, 0xe6, 0xe6, 0x01, 0x00, 0x00,
        0x64, 0x00, 0x31, 0x14, 0x00, 0x08, 0x34, 0x34,
        0x36, 0x34, 0x35, 0x30, 0x5f, 0x32, 0x01, 0x08,
        0x82, 0x84, 0x8b, 0x96, 0x24, 0x30, 0x48, 0x6c,
        0x03, 0x01, 0x02, 0x05, 0x04, 0x00, 0x01, 0x00,
        0x00, 0x2a, 0x01, 0x00, 0x32, 0x04, 0x0c, 0x12,
        0x18, 0x60, 0x30, 0x14, 0x01, 0x00, 0x00, 0x0f,
        0xac, 0x04, 0x01, 0x00, 0x00, 0x0f, 0xac, 0x04,
        0x01, 0x00, 0x00, 0x0f, 0xac, 0x02, 0x0c, 0x00,
        0x46, 0x05, 0x32, 0x08, 0x01, 0x00, 0x00, 0x2d,
        0x1a, 0xbc, 0x09, 0x1b, 0xff, 0xff, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x3d, 0x16, 0x02, 0x08, 0x04,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x4a, 0x0e, 0x14, 0x00, 0x0a,
        0x00, 0x2c, 0x01, 0xc8, 0x00, 0x14, 0x00, 0x05,
        0x00, 0x19, 0x00, 0x7f, 0x08, 0x05, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x40, 0xdd, 0x09, 0x00,
        0x10, 0x18, 0x02, 0x06, 0x00, 0x0c, 0x00, 0x00,
        0xdd, 0x18, 0x00, 0x50, 0xf2, 0x02, 0x01, 0x01,
        0x84, 0x00, 0x03, 0xa4, 0x00, 0x00, 0x27, 0xa4,
        0x00, 0x00, 0x42, 0x43, 0x5e, 0x00, 0x62, 0x32,
        0x2f, 0x00 
    };

    //  You may have noticed that the above frames have different lengths, 
    //  despite being the same frame over the air.  The differences are in 
    //  the radiotap header (38 bytes for the ax200, 24 for the rtl8812) and 
    //  the handling of the fcs (the frame from the ax200 has an fcs, while the
    //  frame from the rtl8812 doesn't).
    
    shootout::Packet p1(pkt1517, 260);
    shootout::Packet p2(pkt85, 242);

    //BOOST_CHECK(memcmp(p1.hash.hash, p2.hash.hash, 32) == 0);
}

